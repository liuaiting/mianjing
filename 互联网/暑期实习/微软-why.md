微软cloud+AI，北京组（投成了开发岗，僵硬）
===
一面，自我介绍，手撕代码：<br>
深度拷贝二叉树，递归和非递归写法。递归就用中序遍历，非递归就用BFS+双队列。<br>
做完题面试官问我对他们组有什么了解，我说我就知道组名。然后面试官就给我说他们主要是做大数据和云计算平台的，以及开发基于云计算平台的各种工具。<br>
一脸懵逼，原来投错岗了。不过面试官又说他们对背景没啥要求，比如他来之前就不知道大数据是啥。然后又闲聊了几句就结束了一面。

二面，自我介绍，手撕代码：<br>
1.对于给定的字符串数组，找到出现频次最高的K个字符串。<br>
说了下思路，哈希+最小堆，然后在白板上把代码写完。<br>
2.稍微修改下规则，对于a和b两个字符串，如果a串的某种排列是b串，那么认为a和b相同。<br>
在1的基础上做下修改就好了，在哈希之前排序。<br>
3.对三类数据进行排序，即A类在前，B类在中，C类在后。简化问题描述，可以认为对只有0，1，2三种元素的数组进行排序，排序后的数组为0在前，1在中，2在后。<br>
这道题应该是考察一种O(n)的算法。参考快排的partition函数，使用三个指针i，j，k进行排序。i=0,j=0,k=n-1。如果a[i]是0，那么交换a[i],a[j]，并且i和j均加一；<br>如果a[i]是2，那么交换a[i]和a[k]，k减一，i加一；否则i加一。<br>
面试官指出算法有bug，并给出了一个测试样例。把上面的算法改为a[i]是2时，交换a[i]和a[k]，k减一之后，通过了这个测试样例。<br>
二面结束。

三面，自我介绍，手撕代码：<br>
二叉树的序列化和反序列化。<br>
序列化：BFS，定义间隔字符为'。<br>
反序列化：先根据间隔字符分割字符串，然后逆向BFS建二叉树。<br>
最开始写的代码有bug，改了半天改好了，三面就结束了。

回来等通知。
