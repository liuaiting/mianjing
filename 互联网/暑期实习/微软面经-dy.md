一面：
先自我介绍一下
1字符串中的最长回文子串问题
我答了动态规划的解法，
面试官：你能不能想出O（n）的解法
我：想了一会儿放弃了
面试官：Manacher法了解吗
我：不了解
2 找出大数据中最大的n个数
答：法1：分成多个小文件，维护一个节点数为n的最小堆，分别读小文件更新最小堆。
法2： 分成m个小文件，每个小文件读入内存后快排取top n，合并m个top n。
面试官：手写一下堆排序：
我：只写了用java库priorityQueue实现的方式 
面试官: 不用库写一下
我：没写出来
3 有若干个酒店，给定每个酒店到顾客的距离以及价格，要求返回价格最低的n个酒店，且返回的每个酒店都是同价位下距离最近的。
我：维护一个酒店数组，每个元素的下标表示价格，值为一个酒店对象，存储当前价格下距离最近的酒店。便利酒店集合，若当前价格已存在，则更新为这两个酒店中距离最短的一个。
最后顺序便利酒店数组，依次输出不为空的n个酒店。

后面跟小哥扯了扯蛋，一面勉强过的。他说你这个还行吧，但准备的不是很充分啊，得好好准备的，虽然不是最好的，但还是给你过了吧，给你个机会。

二面：
自我介绍
1给定n个字符串，计算出出现次数最多的字符串，n很大
我：首先想到的肯定是hash表，但空间复杂度太高，我再想想
我： 用Trie 树可以
面试官：那你用Trie树把这道题的完整代码写一下
我：手撕成功
面试官：如果是出现次数最多的前n个字符串呢？
我：建立Trie树的同时维护一个最小堆
面试官：假设你现在是黑客，写一些测试用例来攻击你的代码
我：我的代码中子树是用数组实现的，默认大小26，只能处理小写字母的单词，若有大写字母则会出错，为了解决这个问题，可以将Trie树的子树数组扩大为255，以ASCII码为key。
面试官：嗯，还有呢，继续
我：还有可能出现中文字符，这样就需要改变子树的实现方式，不用数组而是使用HashMap来实现。
面试官：继续，再想
我：还有可能出现当前码表之外的字符，比如我用的gbk编码，但是出现了日文等，解决方法可以使用别的码表如utf-8
面试官：继续，你还能怎么搞崩这个程序
我：输入一个巨大的字符串，撑爆内存
面试官：正常情况下有可能出错吗？
我：代码是线程不安全的，多线程可能出错，可以用volatile修饰

二面感觉答的贼好，只用了不到40分钟

三面：
自我介绍
讲一个你做过最难的任务
1 一颗二叉树中有一个叶子节点，它有一个指针错误地指向了树中的一个其他节点，如何找到这个节点并删除这个错误的指针？
我：用hashSet加先序遍历，如果下一个节点已经访问过则找出，删除指向该节点的指针（不完全）
然后面试官指出来一个缺陷，上述算法可能会删除非叶节点的那个指针，然后引导一番，让我改进并写出完整代码
我：写出来了，应该是过了
2 两个长度为n 的数组 ，找出两个数组中第n小的数 （LeetCode原题）
我 用二分法答出，应该也算过了

三面稍微卡了些，不过在面试官的引导下还是勉强做出来了

offer已收
